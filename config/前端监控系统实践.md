# 前端监控系统详细实践方案

## 目录

- [前端监控系统详细实践方案](#前端监控系统详细实践方案)
  - [目录](#目录)
  - [前言](#前言)
  - [前端监控系统概述](#前端监控系统概述)
    - [为什么需要前端监控](#为什么需要前端监控)
    - [监控指标分类](#监控指标分类)
    - [监控系统架构](#监控系统架构)
  - [基于 Sentry 的前端监控实践](#基于-sentry-的前端监控实践)
    - [Sentry 简介](#sentry-简介)
    - [Sentry 部署方案](#sentry-部署方案)
      - [方案一：使用 Sentry 云服务](#方案一使用-sentry-云服务)
      - [方案二：自建 Sentry 服务](#方案二自建-sentry-服务)
    - [Sentry 前端集成](#sentry-前端集成)
      - [Vue 项目集成](#vue-项目集成)
      - [React 项目集成](#react-项目集成)
      
    - [Sentry 高级配置](#sentry-高级配置)
      - [SourceMap 上传](#sourcemap-上传)
      - [性能监控配置](#性能监控配置)
      - [用户信息关联](#用户信息关联)
      - [自定义上下文](#自定义上下文)
    - [Sentry 告警配置](#sentry-告警配置)
    - [Sentry 最佳实践](#sentry-最佳实践)
  - [基于 WebTracing 的前端监控实践](#基于-webtracing-的前端监控实践)
    - [WebTracing 简介](#webtracing-简介)
    - [WebTracing 架构设计](#webtracing-架构设计)
    - [WebTracing 部署方案](#webtracing-部署方案)
      - [后端服务部署](#后端服务部署)
      - [数据存储选型](#数据存储选型)
    - [WebTracing SDK 集成](#webtracing-sdk-集成)
      - [基础配置](#基础配置)
      - [性能指标采集](#性能指标采集)
      - [错误监控](#错误监控)
      - [用户行为追踪](#用户行为追踪)
      - [网络请求监控](#网络请求监控)
    - [WebTracing 数据分析与可视化](#webtracing-数据分析与可视化)
    - [WebTracing 最佳实践](#webtracing-最佳实践)
  - [监控系统方案对比](#监控系统方案对比)
    - [功能对比](#功能对比)
    - [性能对比](#性能对比)
    - [成本对比](#成本对比)
    - [适用场景](#适用场景)
  - [监控系统落地案例](#监控系统落地案例)
    - [大型电商平台监控实践](#大型电商平台监控实践)
    - [中小型 SaaS 应用监控实践](#中小型-saas-应用监控实践)
  - [总结与展望](#总结与展望)

## 前言

随着前端应用的复杂度不断提高，前端监控系统已经成为保障应用质量和用户体验的关键基础设施。本文将详细介绍基于 Sentry 和 WebTracing 两种主流方案的前端监控系统实践，包括系统架构、部署方案、集成方法、配置优化以及最佳实践，帮助开发团队快速搭建高效的前端监控体系。

## 前端监控系统概述

### 为什么需要前端监控

前端监控系统的价值主要体现在以下几个方面：

1. **问题快速发现**：实时监控前端应用运行状态，第一时间发现异常
2. **用户体验提升**：通过性能指标监控，持续优化用户体验
3. **业务数据分析**：结合用户行为数据，为产品决策提供依据
4. **开发效率提升**：减少问题排查时间，提高开发团队效率
5. **预防问题发生**：通过趋势分析，预判可能出现的问题

### 监控指标分类

前端监控系统通常关注以下几类指标：

1. **错误监控**
   - JavaScript 异常
   - Promise 异常
   - 资源加载异常
   - API 请求异常
   - 框架特定异常

2. **性能监控**
   - 页面加载性能（FP、FCP、LCP 等）
   - 交互响应性能（FID、TTI 等）
   - 资源加载性能
   - JavaScript 执行性能
   - 内存使用情况

3. **用户行为监控**
   - PV/UV 统计
   - 用户点击行为
   - 页面停留时间
   - 页面跳转路径
   - 用户操作轨迹

4. **业务指标监控**
   - 转化率
   - 功能使用频率
   - 自定义业务指标

### 监控系统架构

一个完整的前端监控系统通常包含以下核心组件：

1. **数据采集层**：前端 SDK，负责采集各类监控数据
2. **数据传输层**：将采集的数据安全高效地传输到服务端
3. **数据处理层**：对原始数据进行清洗、聚合和分析
4. **数据存储层**：持久化存储处理后的监控数据
5. **数据展示层**：直观展示监控数据和分析结果
6. **告警系统**：根据预设规则触发告警通知

## 基于 Sentry 的前端监控实践

### Sentry 简介

Sentry 是一个开源的实时错误跟踪系统，支持多种编程语言和框架，能够帮助开发者实时监控和修复线上问题。Sentry 提供了云服务和自建部署两种使用方式，具有以下特点：

- 实时错误捕获和报告
- 详细的错误上下文信息
- 源码映射支持（SourceMap）
- 性能监控功能
- 丰富的集成能力
- 完善的告警机制

### Sentry 部署方案

#### 方案一：使用 Sentry 云服务

**优势**：
- 快速上手，无需维护服务器
- 自动扩展，应对高并发场景
- 持续更新，获取最新功能

**步骤**：
1. 注册 Sentry 账号：https://sentry.io
2. 创建组织和项目
3. 获取 DSN（Data Source Name）
4. 前端项目集成 SDK

#### 方案二：自建 Sentry 服务

**优势**：
- 数据私有化存储
- 可定制化程度高
- 长期使用成本较低

**部署步骤**：

1. **准备环境**

   ```bash
   # 克隆官方部署仓库
   git clone https://github.com/getsentry/onpremise.git
   cd onpremise
   
   # 安装 Docker 和 Docker Compose
   # Ubuntu
   apt-get update && apt-get install docker.io docker-compose -y
   
   # CentOS
   yum install docker docker-compose -y
   systemctl start docker && systemctl enable docker
   ```

2. **配置环境变量**

   创建 `.env` 文件：

   ```
   COMPOSE_PROJECT_NAME=sentry
   SENTRY_EVENT_RETENTION_DAYS=90
   # 生成密钥
   SENTRY_SECRET_KEY=$(docker-compose run --rm web config generate-secret-key)
   ```

3. **启动服务**

   ```bash
   # 初始化服务
   ./install.sh
   
   # 创建管理员账号
   docker-compose run --rm web createuser --superuser --email admin@example.com --password <your-password>
   
   # 启动所有服务
   docker-compose up -d
   ```

4. **配置 Nginx 反向代理**（可选）

   ```nginx
   server {
       listen 80;
       server_name sentry.example.com;
   
       location / {
           proxy_pass http://localhost:9000;
           proxy_set_header Host $host;
           proxy_set_header X-Real-IP $remote_addr;
           proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
           proxy_set_header X-Forwarded-Proto $scheme;
       }
   }
   ```

5. **配置 HTTPS**（推荐）

   使用 Let's Encrypt 配置 HTTPS：

   ```bash
   apt-get install certbot python3-certbot-nginx -y
   certbot --nginx -d sentry.example.com
   ```

### Sentry 前端集成

#### Vue 项目集成

**Vue 2.x 集成**

1. 安装依赖

   ```bash
   npm install @sentry/vue @sentry/tracing
   ```

2. 初始化配置

   ```javascript
   // main.js
   import Vue from 'vue';
   import Router from 'vue-router';
   import * as Sentry from '@sentry/vue';
   import { BrowserTracing } from '@sentry/tracing';
   
   const router = new Router({
     // 路由配置
   });
   
   Sentry.init({
     Vue,
     dsn: 'https://examplePublicKey@o0.ingest.sentry.io/0',
     integrations: [
       new BrowserTracing({
         routingInstrumentation: Sentry.vueRouterInstrumentation(router),
         tracingOrigins: ['localhost', 'my-site-url.com', /^\//],
       }),
     ],
     tracesSampleRate: 1.0, // 生产环境建议降低采样率，如 0.2
     logErrors: true,
     release: process.env.VUE_APP_VERSION || '1.0.0',
     environment: process.env.NODE_ENV,
   });
   
   new Vue({
     router,
     render: h => h(App),
   }).$mount('#app');
   ```

**Vue 3.x 集成**

1. 安装依赖

   ```bash
   npm install @sentry/vue @sentry/tracing
   ```

2. 初始化配置

   ```javascript
   // main.js
   import { createApp } from 'vue';
   import { createRouter } from 'vue-router';
   import * as Sentry from '@sentry/vue';
   import { BrowserTracing } from '@sentry/tracing';
   import App from './App.vue';
   
   const app = createApp(App);
   const router = createRouter({
     // 路由配置
   });
   
   app.use(router);
   
   Sentry.init({
     app,
     dsn: 'https://examplePublicKey@o0.ingest.sentry.io/0',
     integrations: [
       new BrowserTracing({
         routingInstrumentation: Sentry.vueRouterInstrumentation(router),
         tracingOrigins: ['localhost', 'my-site-url.com', /^\//],
       }),
     ],
     tracesSampleRate: 1.0,
     release: process.env.VUE_APP_VERSION || '1.0.0',
     environment: process.env.NODE_ENV,
   });
   
   app.mount('#app');
   ```

#### React 项目集成

1. 安装依赖

   ```bash
   npm install @sentry/react @sentry/tracing
   ```

2. 初始化配置

   ```javascript
   // index.js
   import React from 'react';
   import ReactDOM from 'react-dom';
   import { BrowserRouter } from 'react-router-dom';
   import * as Sentry from '@sentry/react';
   import { BrowserTracing } from '@sentry/tracing';
   import App from './App';
   
   Sentry.init({
     dsn: 'https://examplePublicKey@o0.ingest.sentry.io/0',
     integrations: [
       new BrowserTracing({
         routingInstrumentation: Sentry.reactRouterV5Instrumentation(
           React.useHistory,
           React.useLocation,
           React.useRouteMatch,
         ),
         tracingOrigins: ['localhost', 'my-site-url.com', /^\//],
       }),
     ],
     tracesSampleRate: 1.0,
     release: process.env.REACT_APP_VERSION || '1.0.0',
     environment: process.env.NODE_ENV,
   });
   
   ReactDOM.render(
     <BrowserRouter>
       <App />
     </BrowserRouter>,
     document.getElementById('root')
   );
   ```

3. 使用错误边界组件

   ```javascript
   // App.js
   import React from 'react';
   import * as Sentry from '@sentry/react';
   
   const FallbackComponent = () => (
     <div className="error-boundary">
       <h2>出错了！</h2>
       <p>应用遇到了问题，请刷新页面或联系客服。</p>
     </div>
   );
   
   const App = () => (
     <Sentry.ErrorBoundary fallback={FallbackComponent}>
       {/* 应用组件 */}
     </Sentry.ErrorBoundary>
   );
   
   export default App;
   ```

### Sentry 高级配置

#### SourceMap 上传

为了在生产环境中准确定位错误位置，需要上传 SourceMap 文件：

1. **安装 Sentry CLI**

   ```bash
   npm install @sentry/cli --save-dev
   ```

2. **配置 Sentry CLI**

   创建 `.sentryclirc` 文件：

   ```ini
   [auth]
   token=your-auth-token
   
   [defaults]
   url=https://sentry.io/
   org=your-org-name
   project=your-project-name
   ```

3. **配置 Webpack 插件**

   ```javascript
   // vue.config.js (Vue CLI)
   const SentryWebpackPlugin = require('@sentry/webpack-plugin');
   
   module.exports = {
     configureWebpack: {
       plugins: [
         new SentryWebpackPlugin({
           include: './dist',
           ignore: ['node_modules', 'vue.config.js'],
           release: process.env.VUE_APP_VERSION || '1.0.0',
         }),
       ],
     },
   };
   ```

4. **自动化部署脚本**

   ```bash
   #!/bin/bash
   
   # 构建应用
   npm run build
   
   # 创建 release
   npx sentry-cli releases new "$VERSION"
   
   # 上传 SourceMap
   npx sentry-cli releases files "$VERSION" upload-sourcemaps ./dist --url-prefix "~/"
   
   # 完成 release
   npx sentry-cli releases finalize "$VERSION"
   ```

#### 性能监控配置

配置性能监控以跟踪前端性能指标：

```javascript
Sentry.init({
  // 基础配置...
  
  // 启用性能监控
  tracesSampleRate: 0.2, // 采样率，生产环境建议 0.1-0.3
  
  // 自定义性能指标
  tracingOptions: {
    trackComponents: true, // 跟踪组件渲染性能
    timeout: 30000, // 事务超时时间（毫秒）
    idleTimeout: 5000, // 空闲超时时间（毫秒）
  },
});

// 自定义性能事务
const transaction = Sentry.startTransaction({
  name: 'DataLoading',
  op: 'task',
});

// 设置当前事务为活动事务
Sentry.configureScope(scope => {
  scope.setSpan(transaction);
});

// 创建子 span
const span = transaction.startChild({
  op: 'http',
  description: '加载用户数据',
});

// 异步操作
fetchUserData()
  .then(data => {
    // 处理数据...
    span.setStatus('ok');
  })
  .catch(error => {
    span.setStatus('unknown_error');
    Sentry.captureException(error);
  })
  .finally(() => {
    span.finish();
    transaction.finish();
  });
```

#### 用户信息关联

关联用户信息，便于追踪特定用户遇到的问题：

```javascript
// 用户登录后设置用户信息
Sentry.setUser({
  id: '12345',
  email: 'user@example.com',
  username: 'username',
  // 自定义属性
  subscription: 'premium',
  role: 'admin',
});

// 用户登出时清除用户信息
function logout() {
  Sentry.setUser(null);
  // 登出逻辑...
}
```

#### 自定义上下文

添加自定义上下文信息，帮助更好地理解错误发生的环境：

```javascript
// 添加标签（用于分类和筛选）
Sentry.setTag('feature_enabled', 'true');
Sentry.setTag('experiment_group', 'A');

// 添加额外上下文
Sentry.setContext('device', {
  screen_resolution: `${window.screen.width}x${window.screen.height}`,
  orientation: window.screen.orientation.type,
  pixel_ratio: window.devicePixelRatio,
});

// 添加面包屑（用户操作轨迹）
Sentry.addBreadcrumb({
  category: 'ui.click',
  message: '用户点击了提交按钮',
  level: 'info',
});
```

### Sentry 告警配置

Sentry 提供了丰富的告警配置选项，可以根据不同的错误类型和严重程度设置不同的通知规则：

1. **告警规则配置**

   在 Sentry 管理界面中：
   - 进入项目设置 > 告警 > 规则
   - 创建新规则，设置触发条件，如：
     - 新问题出现
     - 问题重新出现
     - 问题频率超过阈值
     - 受影响用户数超过阈值

2. **通知渠道配置**

   支持多种通知渠道：
   - 电子邮件
   - Slack
   - 钉钉
   - 企业微信
   - PagerDuty
   - 自定义 Webhook

3. **告警分级示例**

   ```
   # P0 级别（严重）
   条件：影响用户数 > 100 或 错误率 > 5%
   通知：PagerDuty + Slack + 短信
   
   # P1 级别（高）
   条件：影响用户数 > 50 或 错误率 > 2%
   通知：Slack + 邮件
   
   # P2 级别（中）
   条件：新问题出现
   通知：Slack
   ```

4. **自定义 Webhook 集成**

   ```javascript
   // 接收 Sentry Webhook 的 Express 路由
   app.post('/api/sentry-webhook', (req, res) => {
     const { action, data } = req.body;
     
     if (action === 'created' && data.event) {
       // 处理新问题
       const { title, web_url, project, level } = data;
       
       // 发送到内部系统
       notifyInternalSystem({
         title,
         url: web_url,
         project: project.name,
         level,
         timestamp: new Date().toISOString(),
       });
     }
     
     res.status(200).send('OK');
   });
   ```

### Sentry 最佳实践

1. **错误过滤**

   避免上报无意义的错误：

   ```javascript
   Sentry.init({
     // 其他配置...
     
     beforeSend(event) {
       // 忽略网络错误
       if (event.exception && event.exception.values) {
         const exceptionValue = event.exception.values[0];
         if (exceptionValue.type === 'ChunkLoadError') {
           return null; // 不上报该错误
         }
       }
       
       // 忽略特定来源的错误
       if (event.request && event.request.url) {
         if (event.request.url.includes('third-party-script.js')) {
           return null;
         }
       }
       
       return event;
     },
   });
   ```

2. **采样率优化**

   根据环境和用户类型调整采样率：

   ```javascript
   Sentry.init({
     // 其他配置...
     
     tracesSampler: samplingContext => {
       // 根据环境调整
       if (samplingContext.environment === 'development') {
         return 1.0; // 开发环境 100% 采样
       }
       
       // 根据 URL 路径调整
       if (samplingContext.transactionContext.name.includes('/checkout')) {
         return 0.5; // 结账流程 50% 采样
       }
       
       // 根据用户类型调整
       const user = samplingContext.transactionContext.tags?.user_type;
       if (user === 'premium') {
         return 0.8; // 高级用户 80% 采样
       }
       
       return 0.1; // 默认 10% 采样
     },
   });
   ```

3. **性能优化**

   减少 Sentry 对应用性能的影响：

   ```javascript
   Sentry.init({
     // 其他配置...
     
     // 限制每个事件的附加数据大小
     maxBreadcrumbs: 50,
     
     // 使用更高效的传输方式
     transport: Sentry.makeFetchTransport,
     
     // 批量处理事件
     maxValueLength: 250, // 限制值长度
     normalizeDepth: 5, // 限制对象嵌套深度
     
     // 禁用不需要的集成
     integrations: [
       new Sentry.BrowserTracing({
         // 只跟踪重要的路由
         tracingOrigins: ['example.com'],
       }),
       // 禁用不需要的默认集成
       Sentry.defaultIntegrations.filter(integration => 
         integration.name !== 'Breadcrumbs'
       ),
     ],
   });
   ```

4. **版本管理与发布跟踪**

   ```javascript
   // 在 CI/CD 流程中执行
   const release = `${process.env.PROJECT_NAME}@${process.env.VERSION}`;
   
   // 创建发布版本
   Sentry.init({
     // 其他配置...
     release,
     environment: process.env.NODE_ENV,
   });
   
   // 关联代码提交
   exec(`sentry-cli releases set-commits --auto ${release}`);
   
   // 部署完成后标记发布状态
   exec(`sentry-cli releases deploys ${release} new -e production`);
   ```

5. **自定义错误处理**

   ```javascript
   // 全局错误处理
   window.addEventListener('error', event => {
     // 自定义错误处理逻辑
     const { message, filename, lineno, colno, error } = event;
     
     // 添加自定义上下文
     Sentry.withScope(scope => {
       scope.setLevel('error');
       scope.setExtra('filename', filename);
       scope.setExtra('line', lineno);
       scope.setExtra('column', colno);
       
       // 添加用户操作记录
       scope.addBreadcrumb({
         category: 'error',
         message: `Error occurred at ${filename}:${lineno}:${colno}`,
         level: 'error',
       });
       
       Sentry.captureException(error || new Error(message));
     });
   });
   
   // Promise 错误处理
   window.addEventListener('unhandledrejection', event => {
     Sentry.captureException(event.reason);
   });
   ```

## 基于 WebTracing 的前端监控实践

### WebTracing 简介

WebTracing 是基于 OpenTelemetry 标准的前端监控解决方案，提供了更灵活的自定义能力和更完整的链路追踪功能。与 Sentry 相比，WebTracing 更适合需要深度定制和与后端系统打通的场景。

**核心特点**：

- 基于 OpenTelemetry 标准，兼容性好
- 支持分布式追踪，可与后端链路打通
- 高度可定制，适应复杂业务场景
- 支持多种后端存储和可视化方案
- 开源免费，无商业限制

### WebTracing 架构设计

WebTracing 的整体架构包括以下几个部分：

1. **前端 SDK**：基于 OpenTelemetry JS SDK 开发，负责数据采集
2. **数据传输**：通过 HTTP 或 gRPC 协议传输数据
3. **后端收集器**：OpenTelemetry Collector，负责数据接收、处理和转发
4. **存储系统**：支持 Jaeger、Zipkin、Prometheus、Elasticsearch 等
5. **可视化平台**：Grafana、Jaeger UI、Kibana 等

**架构图**：

```
+----------------+    HTTP/gRPC    +----------------------+
|                |  ------------->  |                      |
|  WebTracing    |                  |  OpenTelemetry       |
|  Browser SDK   |  <-------------  |  Collector           |
|                |    Response      |                      |
+----------------+                  +----------------------+
                                           |       ^
                                           v       |
+----------------+    +----------------+   |       |   +----------------+
|                |    |                |   |       |   |                |
|  Prometheus    |    |  Elasticsearch |   |       |   |  Jaeger        |
|  (Metrics)     |    |  (Logs)        |<--+       +-->|  (Traces)      |
|                |    |                |               |                |
+----------------+    +----------------+               +----------------+
        ^                     ^                               ^
        |                     |                               |
        v                     v                               v
+---------------------------------------------------------------+
|                                                               |
|                        Grafana                                |
|                                                               |
+---------------------------------------------------------------+
```

### WebTracing 部署方案

#### 后端服务部署

1. **使用 Docker Compose 部署 OpenTelemetry Collector**

   创建 `docker-compose.yml` 文件：

   ```yaml
   version: '3'
   services:
     # OpenTelemetry Collector
     otel-collector:
       image: otel/opentelemetry-collector:latest
       command: ["--config=/etc/otel-collector-config.yaml"]
       volumes:
         - ./otel-collector-config.yaml:/etc/otel-collector-config.yaml
       ports:
         - "4317:4317"   # OTLP gRPC
         - "4318:4318"   # OTLP HTTP
         - "8888:8888"   # Metrics
         - "8889:8889"   # Health check
       depends_on:
         - jaeger
         - prometheus
     
     # Jaeger
     jaeger:
       image: jaegertracing/all-in-one:latest
       ports:
         - "16686:16686"  # UI
         - "14250:14250"  # Model
         - "14268:14268"  # Collector
     
     # Prometheus
     prometheus:
       image: prom/prometheus:latest
       volumes:
         - ./prometheus.yml:/etc/prometheus/prometheus.yml
       ports:
         - "9090:9090"
     
     # Grafana
     grafana:
       image: grafana/grafana:latest
       ports:
         - "3000:3000"
       environment:
         - GF_SECURITY_ADMIN_PASSWORD=admin
       volumes:
         - ./grafana-provisioning:/etc/grafana/provisioning
       depends_on:
         - prometheus
         - elasticsearch
     
     # Elasticsearch
     elasticsearch:
       image: docker.elastic.co/elasticsearch/elasticsearch:7.10.0
       environment:
         - discovery.type=single-node
         - ES_JAVA_OPTS=-Xms512m -Xmx512m
       ports:
         - "9200:9200"
     
     # Kibana
     kibana:
       image: docker.elastic.co/kibana/kibana:7.10.0
       ports:
         - "5601:5601"
       depends_on:
         - elasticsearch
   ```

2. **配置 OpenTelemetry Collector**

   创建 `otel-collector-config.yaml` 文件：

   ```yaml
   receivers:
     otlp:
       protocols:
         grpc:
           endpoint: 0.0.0.0:4317
         http:
           endpoint: 0.0.0.0:4318
   
   processors:
     batch:
       timeout: 1s
       send_batch_size: 1024
     memory_limiter:
       check_interval: 1s
       limit_mib: 1000
     resourcedetection:
       detectors: [env]
     filter:
       metrics:
         include:
           match_type: regexp
           metric_names:
             - "web_.*"
   
   exporters:
     jaeger:
       endpoint: jaeger:14250
       tls:
         insecure: true
     prometheus:
       endpoint: 0.0.0.0:8889
     elasticsearch:
       endpoints: ["http://elasticsearch:9200"]
       index: "web-traces"
   
   service:
     pipelines:
       traces:
         receivers: [otlp]
         processors: [memory_limiter, batch, resourcedetection]
         exporters: [jaeger, elasticsearch]
       metrics:
         receivers: [otlp]
         processors: [memory_limiter, batch, filter, resourcedetection]
         exporters: [prometheus]
   ```

3. **配置 Prometheus**

   创建 `prometheus.yml` 文件：

   ```yaml
   global:
     scrape_interval: 15s
     evaluation_interval: 15s
   
   scrape_configs:
     - job_name: 'otel-collector'
       scrape_interval: 10s
       static_configs:
         - targets: ['otel-collector:8889']
   ```

4. **启动服务**

   ```bash
   docker-compose up -d
   ```

#### 数据存储选型

WebTracing 支持多种数据存储方案，可以根据需求选择：

1. **Traces 存储**

   | 存储系统 | 优势 | 适用场景 |
   |---------|------|----------|
   | Jaeger | 专为分布式追踪设计，查询性能好 | 中小规模应用，追踪数据量不大 |
   | Elasticsearch | 搜索能力强，支持复杂查询，可扩展性好 | 大规模应用，需要长期存储和复杂查询 |
   | Tempo | 高效存储，与 Grafana 集成好 | Grafana 生态用户，注重成本效益 |

2. **Metrics 存储**

   | 存储系统 | 优势 | 适用场景 |
   |---------|------|----------|
   | Prometheus | 时序数据库标准，查询语言强大 | 性能指标监控，告警系统集成 |
   | InfluxDB | 写入性能好，支持高基数数据 | 高频指标采集，自定义指标多 |

3. **Logs 存储**

   | 存储系统 | 优势 | 适用场景 |
   |---------|------|----------|
   | Elasticsearch | 全文搜索，聚合分析能力强 | 错误日志分析，需要复杂查询 |
   | Loki | 资源占用低，标签索引 | 与 Grafana 集成，成本敏感 |

### WebTracing SDK 集成

#### 基础配置

1. **安装依赖**

   ```bash
   npm install @opentelemetry/sdk-trace-web @opentelemetry/exporter-trace-otlp-http @opentelemetry/context-zone @opentelemetry/instrumentation @opentelemetry/resources @opentelemetry/semantic-conventions @opentelemetry/sdk-metrics
   ```

2. **初始化 SDK**

   创建 `tracing.js` 文件：

   ```javascript
   import { WebTracerProvider } from '@opentelemetry/sdk-trace-web';
   import { OTLPTraceExporter } from '@opentelemetry/exporter-trace-otlp-http';
   import { BatchSpanProcessor } from '@opentelemetry/sdk-trace-base';
   import { ZoneContextManager } from '@opentelemetry/context-zone';
   import { registerInstrumentations } from '@opentelemetry/instrumentation';
   import { Resource } from '@opentelemetry/resources';
   import { SemanticResourceAttributes } from '@opentelemetry/semantic-conventions';
   import { DocumentLoadInstrumentation } from '@opentelemetry/instrumentation-document-load';
   import { UserInteractionInstrumentation } from '@opentelemetry/instrumentation-user-interaction';
   import { XMLHttpRequestInstrumentation } from '@opentelemetry/instrumentation-xml-http-request';
   import { FetchInstrumentation } from '@opentelemetry/instrumentation-fetch';
   
   // 创建资源信息
   const resource = new Resource({
     [SemanticResourceAttributes.SERVICE_NAME]: 'my-web-app',
     [SemanticResourceAttributes.SERVICE_VERSION]: '1.0.0',
     [SemanticResourceAttributes.DEPLOYMENT_ENVIRONMENT]: process.env.NODE_ENV,
   });
   
   // 创建导出器
   const exporter = new OTLPTraceExporter({
     url: 'http://localhost:4318/v1/traces',
   });
   
   // 创建处理器
   const processor = new BatchSpanProcessor(exporter);
   
   // 创建提供器
   const provider = new WebTracerProvider({
     resource,
   });
   
   // 添加处理器
   provider.addSpanProcessor(processor);
   
   // 注册提供器
   provider.register({
     contextManager: new ZoneContextManager(),
   });
   
   // 注册自动检测
   registerInstrumentations({
     instrumentations: [
       // 页面加载性能
       new DocumentLoadInstrumentation(),
       // 用户交互
       new UserInteractionInstrumentation({
         eventNames: ['click', 'submit'],
       }),
       // XHR 请求
       new XMLHttpRequestInstrumentation({
         propagateTraceHeaderCorsUrls: [/.*/],
       }),
       // Fetch 请求
       new FetchInstrumentation({
         propagateTraceHeaderCorsUrls: [/.*/],
       }),
     ],
   });
   
   // 获取 tracer 实例
   const tracer = provider.getTracer('web-tracer');
   
   export { tracer };
   ```

3. **在应用入口引入**

   ```javascript
   // main.js 或 index.js
   import './tracing';
   
   // 其他应用代码...
   ```

#### 性能指标采集

1. **Web Vitals 指标采集**

   ```javascript
   import { tracer } from './tracing';
   import { getMeasurement } from '@opentelemetry/sdk-trace-web';
   import { onLCP, onFID, onCLS, onTTFB, onFCP } from 'web-vitals';
   
   // 创建指标上报函数
   function reportWebVital(name, value, attribution) {
     const span = tracer.startSpan(`web.${name.toLowerCase()}`);
     span.setAttribute('web.vital.name', name);
     span.setAttribute('web.vital.value', value);
     
     // 添加归因信息
     if (attribution) {
       Object.entries(attribution).forEach(([key, value]) => {
         if (value && typeof value === 'object') {
           span.setAttribute(`web.vital.attribution.${key}`, JSON.stringify(value));
         } else if (value !== undefined && value !== null) {
           span.setAttribute(`web.vital.attribution.${key}`, String(value));
         }
       });
     }
     
     span.end();
   }
   
   // 注册 Web Vitals 监听
   onLCP(metric => reportWebVital('LCP', metric.value, metric.attribution));
   onFID(metric => reportWebVital('FID', metric.value, metric.attribution));
   onCLS(metric => reportWebVital('CLS', metric.value, metric.attribution));
   onTTFB(metric => reportWebVital('TTFB', metric.value, metric.attribution));
   onFCP(metric => reportWebVital('FCP', metric.value, metric.attribution));
   ```

2. **自定义性能指标**

   ```javascript
   import { tracer } from './tracing';
   import { metrics, ValueType } from '@opentelemetry/api-metrics';
   
   // 创建指标记录器
   const meter = metrics.getMeter('web-metrics');
   
   // 创建计数器
   const pageViewCounter = meter.createCounter('web.page_views', {
     description: '页面浏览次数',
     valueType: ValueType.INT,
   });
   
   // 创建直方图
   const resourceLoadHistogram = meter.createHistogram('web.resource_load_time', {
     description: '资源加载时间分布',
     unit: 'ms',
     valueType: ValueType.DOUBLE,
   });
   
   // 记录页面浏览
   function recordPageView() {
     const url = window.location.pathname;
     pageViewCounter.add(1, { page: url });
   }
   
   // 记录资源加载时间
   function recordResourceTiming() {
     const resources = performance.getEntriesByType('resource');
     
     resources.forEach(resource => {
       const { name, initiatorType, duration } = resource;
       
       resourceLoadHistogram.record(duration, {
         resource_type: initiatorType,
         resource_url: name,
       });
     });
   }
   
   // 页面加载完成后记录
   window.addEventListener('load', () => {
     recordPageView();
     recordResourceTiming();
   });
   ```

#### 错误监控

1. **全局错误捕获**

   ```javascript
   import { tracer } from './tracing';
   import { SpanStatusCode } from '@opentelemetry/api';
   
   // 捕获 JS 错误
   window.addEventListener('error', event => {
     const { message, filename, lineno, colno, error } = event;
     
     const span = tracer.startSpan('error.uncaught');
     span.setStatus({
       code: SpanStatusCode.ERROR,
       message: message,
     });
     
     span.setAttribute('error.type', error?.name || 'Error');
     span.setAttribute('error.message', message);
     span.setAttribute('error.stack', error?.stack || '');
     span.setAttribute('error.source', filename);
     span.setAttribute('error.lineno', lineno);
     span.setAttribute('error.colno', colno);
     span.setAttribute('error.url', window.location.href);
     
     // 添加用户信息
     const user = getUserInfo(); // 自定义函数获取用户信息
     if (user) {
       span.setAttribute('user.id', user.id);
       span.setAttribute('user.type', user.type);
     }
     
     span.end();
   }, true);
   
   // 捕获 Promise 错误
   window.addEventListener('unhandledrejection', event => {
     const error = event.reason;
     const message = error?.message || 'Unhandled Promise Rejection';
     
     const span = tracer.startSpan('error.unhandledrejection');
     span.setStatus({
       code: SpanStatusCode.ERROR,
       message: message,
     });
     
     span.setAttribute('error.type', 'UnhandledRejection');
     span.setAttribute('error.message', message);
     span.setAttribute('error.stack', error?.stack || '');
     span.setAttribute('error.url', window.location.href);
     
     span.end();
   });
   ```

2. **Vue 错误处理**

   ```javascript
   // Vue 2.x
   import Vue from 'vue';
   import { tracer } from './tracing';
   import { SpanStatusCode } from '@opentelemetry/api';
   
   Vue.config.errorHandler = (error, vm, info) => {
     const span = tracer.startSpan('error.vue');
     span.setStatus({
       code: SpanStatusCode.ERROR,
       message: error.message,
     });
     
     span.setAttribute('error.type', error.name);
     span.setAttribute('error.message', error.message);
     span.setAttribute('error.stack', error.stack);
     span.setAttribute('error.component', vm.$options.name || 'AnonymousComponent');
     span.setAttribute('error.info', info);
     span.setAttribute('error.url', window.location.href);
     
     span.end();
     
     // 可以继续抛出错误以便控制台显示
     console.error(error);
   };
   ```

3. **React 错误处理**

   ```javascript
   // ErrorBoundary.jsx
   import React from 'react';
   import { tracer } from './tracing';
   import { SpanStatusCode } from '@opentelemetry/api';
   
   class ErrorBoundary extends React.Component {
     constructor(props) {
       super(props);
       this.state = { hasError: false };
     }
     
     static getDerivedStateFromError(error) {
       return { hasError: true };
     }
     
     componentDidCatch(error, errorInfo) {
       const span = tracer.startSpan('error.react');
       span.setStatus({
         code: SpanStatusCode.ERROR,
         message: error.message,
       });
       
       span.setAttribute('error.type', error.name);
       span.setAttribute('error.message', error.message);
       span.setAttribute('error.stack', error.stack);
       span.setAttribute('error.component', this.constructor.name);
       span.setAttribute('error.componentStack', errorInfo.componentStack);
       span.setAttribute('error.url', window.location.href);
       
       span.end();
     }
     
     render() {
       if (this.state.hasError) {
         return this.props.fallback || <h2>出错了！</h2>;
       }
       
       return this.props.children;
     }
   }
   
   export default ErrorBoundary;
   ```

#### 用户行为追踪

1. **页面导航追踪**

   ```javascript
   import { tracer } from './tracing';
   
   // 单页应用路由变化追踪
   let currentRoute = window.location.pathname;
   
   // 创建路由变化监听函数
   function setupRouteTracing() {
     // 监听 history 变化
     const originalPushState = history.pushState;
     const originalReplaceState = history.replaceState;
     
     history.pushState = function() {
       originalPushState.apply(this, arguments);
       handleRouteChange();
     };
     
     history.replaceState = function() {
       originalReplaceState.apply(this, arguments);
       handleRouteChange();
     };
     
     // 监听 popstate 事件
     window.addEventListener('popstate', handleRouteChange);
     
     // 处理路由变化
     function handleRouteChange() {
       const newRoute = window.location.pathname;
       
       if (newRoute !== currentRoute) {
         const span = tracer.startSpan('navigation.route_change');
         span.setAttribute('navigation.from', currentRoute);
         span.setAttribute('navigation.to', newRoute);
         span.setAttribute('navigation.type', 'spa');
         span.end();
         
         currentRoute = newRoute;
       }
     }
   }
   
   setupRouteTracing();
   ```

2. **用户点击行为追踪**

   ```javascript
   import { tracer } from './tracing';
   import { context, trace } from '@opentelemetry/api';
   
   // 创建点击事件监听
   function setupClickTracking() {
     document.addEventListener('click', event => {
       // 获取点击元素
       const target = event.target;
       
       // 获取元素信息
       const tagName = target.tagName.toLowerCase();
       const id = target.id;
       const classList = Array.from(target.classList).join(' ');
       const text = target.innerText?.substring(0, 50);
       const href = target.href || '';
       
       // 创建点击事件 span
       const clickSpan = tracer.startSpan('user.click');
       clickSpan.setAttribute('user.action', 'click');
       clickSpan.setAttribute('target.element', tagName);
       clickSpan.setAttribute('target.id', id);
       clickSpan.setAttribute('target.class', classList);
       clickSpan.setAttribute('target.text', text);
       clickSpan.setAttribute('target.href', href);
       clickSpan.setAttribute('page.url', window.location.href);
       clickSpan.setAttribute('page.title', document.title);
       
       // 如果是链接点击，记录目标 URL
       if (tagName === 'a' && href) {
         clickSpan.setAttribute('navigation.target_url', href);
       }
       
       // 如果是按钮点击，记录按钮类型
       if (tagName === 'button') {
         clickSpan.setAttribute('button.type', target.type || 'button');
       }
       
       clickSpan.end();
     }, true);
   }
   
   setupClickTracking();
   ```

3. **表单提交追踪**

   ```javascript
   import { tracer } from './tracing';
   
   // 创建表单提交监听
   function setupFormTracking() {
     document.addEventListener('submit', event => {
       const form = event.target;
       
       // 获取表单信息
       const formId = form.id;
       const formName = form.name;
       const formAction = form.action;
       const formMethod = form.method.toUpperCase();
       
       // 创建表单提交 span
       const formSpan = tracer.startSpan('user.form_submit');
       formSpan.setAttribute('form.id', formId);
       formSpan.setAttribute('form.name', formName);
       formSpan.setAttribute('form.action', formAction);
       formSpan.setAttribute('form.method', formMethod);
       formSpan.setAttribute('page.url', window.location.href);
       
       // 获取表单字段数量（不记录具体值以保护隐私）
       const inputCount = form.querySelectorAll('input').length;
       const selectCount = form.querySelectorAll('select').length;
       const textareaCount = form.querySelectorAll('textarea').length;
       
       formSpan.setAttribute('form.input_count', inputCount);
       formSpan.setAttribute('form.select_count', selectCount);
       formSpan.setAttribute('form.textarea_count', textareaCount);
       
       formSpan.end();
     }, true);
   }
   
   setupFormTracking();
   ```

#### 网络请求监控

1. **Fetch API 监控**

   ```javascript
   import { tracer } from './tracing';
   import { SpanStatusCode } from '@opentelemetry/api';
   
   // 增强 Fetch API 监控
   function enhanceFetchMonitoring() {
     const originalFetch = window.fetch;
     
     window.fetch = async function(input, init) {
       const url = typeof input === 'string' ? input : input.url;
       const method = init?.method || 'GET';
       
       // 创建 span
       const span = tracer.startSpan('http.fetch');
       span.setAttribute('http.url', url);
       span.setAttribute('http.method', method);
       
       // 添加请求头大小
       if (init?.headers) {
         const headerSize = JSON.stringify(init.headers).length;
         span.setAttribute('http.request_header_size', headerSize);
       }
       
       // 添加请求体大小
       if (init?.body) {
         let bodySize = 0;
         if (typeof init.body === 'string') {
           bodySize = init.body.length;
         } else if (init.body instanceof FormData || init.body instanceof URLSearchParams) {
           bodySize = String(init.body).length;
         } else if (init.body instanceof Blob) {
           bodySize = init.body.size;
         }
         span.setAttribute('http.request_body_size', bodySize);
       }
       
       try {
         const response = await originalFetch.apply(this, arguments);
         
         // 记录响应信息
         span.setAttribute('http.status_code', response.status);
         span.setAttribute('http.status_text', response.statusText);
         span.setAttribute('http.response_content_type', response.headers.get('content-type') || '');
         
         // 克隆响应以获取响应体大小
         const clonedResponse = response.clone();
         const buffer = await clonedResponse.arrayBuffer();
         span.setAttribute('http.response_body_size', buffer.byteLength);
         
         // 设置状态
         if (response.ok) {
           span.setStatus({ code: SpanStatusCode.OK });
         } else {
           span.setStatus({
             code: SpanStatusCode.ERROR,
             message: `HTTP Error ${response.status}: ${response.statusText}`,
           });
         }
         
         span.end();
         return response;
       } catch (error) {
          span.setStatus({
            code: SpanStatusCode.ERROR,
            message: error.message,
          });
          span.setAttribute('error.type', error.name || 'FetchError');
          span.setAttribute('error.message', error.message);
          span.setAttribute('error.stack', error.stack || '');
          
          span.end();
          throw error;
        }
      };
    }
    
    enhanceFetchMonitoring();
    ```

2. **Axios 拦截器监控**

   ```javascript
   import { tracer } from './tracing';
   import { SpanStatusCode } from '@opentelemetry/api';
   import axios from 'axios';
   
   // 设置 Axios 拦截器
   function setupAxiosMonitoring() {
     // 请求拦截器
     axios.interceptors.request.use(config => {
       // 创建 span
       const span = tracer.startSpan('http.axios');
       
       // 保存 span 到请求配置中
       config._otelSpan = span;
       
       // 记录请求信息
       span.setAttribute('http.method', config.method.toUpperCase());
       span.setAttribute('http.url', config.url);
       span.setAttribute('http.request_timeout', config.timeout);
       
       // 记录请求头信息（排除敏感信息）
       const headers = { ...config.headers };
       delete headers.Authorization;
       delete headers.Cookie;
       span.setAttribute('http.request_headers', JSON.stringify(headers));
       
       // 记录请求体大小
       if (config.data) {
         const bodySize = JSON.stringify(config.data).length;
         span.setAttribute('http.request_body_size', bodySize);
       }
       
       return config;
     }, error => {
       // 请求错误
       const span = tracer.startSpan('http.axios.error');
       span.setStatus({
         code: SpanStatusCode.ERROR,
         message: error.message,
       });
       span.setAttribute('error.type', 'AxiosRequestError');
       span.setAttribute('error.message', error.message);
       span.end();
       
       return Promise.reject(error);
     });
     
     // 响应拦截器
     axios.interceptors.response.use(response => {
       const span = response.config._otelSpan;
       
       if (span) {
         // 记录响应信息
         span.setAttribute('http.status_code', response.status);
         span.setAttribute('http.response_size', JSON.stringify(response.data).length);
         span.setAttribute('http.response_time', Date.now() - response.config.metadata.startTime);
         
         // 设置状态
         span.setStatus({ code: SpanStatusCode.OK });
         
         span.end();
       }
       
       return response;
     }, error => {
       const span = error.config?._otelSpan;
       
       if (span) {
         // 记录错误信息
         span.setStatus({
           code: SpanStatusCode.ERROR,
           message: error.message,
         });
         
         if (error.response) {
           // 服务器响应错误
           span.setAttribute('http.status_code', error.response.status);
           span.setAttribute('http.status_text', error.response.statusText);
           span.setAttribute('error.type', 'AxiosResponseError');
         } else if (error.request) {
           // 请求未收到响应
           span.setAttribute('error.type', 'AxiosNoResponseError');
         } else {
           // 请求配置错误
           span.setAttribute('error.type', 'AxiosConfigError');
         }
         
         span.setAttribute('error.message', error.message);
         span.end();
       }
       
       return Promise.reject(error);
     });
   }
   
   setupAxiosMonitoring();
   ```

### WebTracing 数据分析与可视化

基于 WebTracing 收集的数据，可以构建丰富的分析和可视化面板：

1. **Grafana 仪表盘配置**

   创建 `grafana-provisioning/dashboards/web-monitoring.json` 文件：

   ```json
   {
     "annotations": {
       "list": [
         {
           "builtIn": 1,
           "datasource": "-- Grafana --",
           "enable": true,
           "hide": true,
           "iconColor": "rgba(0, 211, 255, 1)",
           "name": "Annotations & Alerts",
           "type": "dashboard"
         }
       ]
     },
     "editable": true,
     "gnetId": null,
     "graphTooltip": 0,
     "id": 1,
     "links": [],
     "panels": [
       {
         "aliasColors": {},
         "bars": false,
         "dashLength": 10,
         "dashes": false,
         "datasource": "Prometheus",
         "fieldConfig": {
           "defaults": {
             "custom": {}
           },
           "overrides": []
         },
         "fill": 1,
         "fillGradient": 0,
         "gridPos": {
           "h": 8,
           "w": 12,
           "x": 0,
           "y": 0
         },
         "hiddenSeries": false,
         "id": 2,
         "legend": {
           "avg": false,
           "current": false,
           "max": false,
           "min": false,
           "show": true,
           "total": false,
           "values": false
         },
         "lines": true,
         "linewidth": 1,
         "nullPointMode": "null",
         "options": {
           "alertThreshold": true
         },
         "percentage": false,
         "pluginVersion": "7.2.0",
         "pointradius": 2,
         "points": false,
         "renderer": "flot",
         "seriesOverrides": [],
         "spaceLength": 10,
         "stack": false,
         "steppedLine": false,
         "targets": [
           {
             "expr": "web_page_views_total",
             "interval": "",
             "legendFormat": "{{page}}",
             "refId": "A"
           }
         ],
         "thresholds": [],
         "timeFrom": null,
         "timeRegions": [],
         "timeShift": null,
         "title": "页面浏览量",
         "tooltip": {
           "shared": true,
           "sort": 0,
           "value_type": "individual"
         },
         "type": "graph",
         "xaxis": {
           "buckets": null,
           "mode": "time",
           "name": null,
           "show": true,
           "values": []
         },
         "yaxes": [
           {
             "format": "short",
             "label": null,
             "logBase": 1,
             "max": null,
             "min": null,
             "show": true
           },
           {
             "format": "short",
             "label": null,
             "logBase": 1,
             "max": null,
             "min": null,
             "show": true
           }
         ],
         "yaxis": {
           "align": false,
           "alignLevel": null
         }
       },
       {
         "aliasColors": {},
         "bars": false,
         "dashLength": 10,
         "dashes": false,
         "datasource": "Prometheus",
         "fieldConfig": {
           "defaults": {
             "custom": {}
           },
           "overrides": []
         },
         "fill": 1,
         "fillGradient": 0,
         "gridPos": {
           "h": 8,
           "w": 12,
           "x": 12,
           "y": 0
         },
         "hiddenSeries": false,
         "id": 4,
         "legend": {
           "avg": false,
           "current": false,
           "max": false,
           "min": false,
           "show": true,
           "total": false,
           "values": false
         },
         "lines": true,
         "linewidth": 1,
         "nullPointMode": "null",
         "options": {
           "alertThreshold": true
         },
         "percentage": false,
         "pluginVersion": "7.2.0",
         "pointradius": 2,
         "points": false,
         "renderer": "flot",
         "seriesOverrides": [],
         "spaceLength": 10,
         "stack": false,
         "steppedLine": false,
         "targets": [
           {
             "expr": "histogram_quantile(0.95, sum(rate(web_resource_load_time_bucket[5m])) by (le, resource_type))",
             "interval": "",
             "legendFormat": "{{resource_type}}",
             "refId": "A"
           }
         ],
         "thresholds": [],
         "timeFrom": null,
         "timeRegions": [],
         "timeShift": null,
         "title": "资源加载时间 (P95)",
         "tooltip": {
           "shared": true,
           "sort": 0,
           "value_type": "individual"
         },
         "type": "graph",
         "xaxis": {
           "buckets": null,
           "mode": "time",
           "name": null,
           "show": true,
           "values": []
         },
         "yaxes": [
           {
             "format": "ms",
             "label": null,
             "logBase": 1,
             "max": null,
             "min": null,
             "show": true
           },
           {
             "format": "short",
             "label": null,
             "logBase": 1,
             "max": null,
             "min": null,
             "show": true
           }
         ],
         "yaxis": {
           "align": false,
           "alignLevel": null
         }
       }
     ],
     "refresh": "5s",
     "schemaVersion": 26,
     "style": "dark",
     "tags": [],
     "templating": {
       "list": []
     },
     "time": {
       "from": "now-6h",
       "to": "now"
     },
     "timepicker": {},
     "timezone": "",
     "title": "Web 监控仪表盘",
     "uid": "web-monitoring",
     "version": 1
   }
   ```

2. **Jaeger UI 配置**

   Jaeger UI 提供了分布式追踪可视化，可以通过 `http://localhost:16686` 访问。主要功能包括：

   - 服务依赖图：展示服务间调用关系
   - 追踪查询：按服务、操作、标签等筛选追踪数据
   - 追踪详情：展示完整的调用链和时间分布
   - 比较视图：对比不同追踪的差异

3. **Kibana 仪表盘**

   创建 Kibana 索引模式和可视化：

   - 创建索引模式：`web-traces*`
   - 创建错误分析仪表盘，包含：
     - 错误类型分布饼图
     - 错误趋势时间线图
     - 按页面分组的错误表格
     - 错误详情列表

### WebTracing 最佳实践

1. **性能优化**

   ```javascript
   // 优化采样策略
   const provider = new WebTracerProvider({
     resource,
     sampler: new ParentBasedSampler({
       root: new TraceIdRatioBased(0.2), // 生产环境采样率 20%
     }),
   });
   
   // 批处理优化
   const processor = new BatchSpanProcessor(exporter, {
     maxQueueSize: 100, // 最大队列大小
     maxExportBatchSize: 10, // 最大批处理大小
     scheduledDelayMillis: 500, // 调度延迟
     exportTimeoutMillis: 30000, // 导出超时
   });
   ```

2. **错误过滤**

   ```javascript
   // 过滤不需要的错误
   window.addEventListener('error', event => {
     // 忽略第三方脚本错误
     if (event.filename && isThirdPartyScript(event.filename)) {
       event.preventDefault();
       return;
     }
     
     // 忽略 CORS 错误
     if (event.message && event.message.includes('Script error.')) {
       event.preventDefault();
       return;
     }
     
     // 处理其他错误...
   }, true);
   
   function isThirdPartyScript(url) {
     const thirdPartyDomains = [
       'cdn.example.com',
       'analytics.example.com',
     ];
     
     return thirdPartyDomains.some(domain => url.includes(domain));
   }
   ```

3. **用户隐私保护**

   ```javascript
   // 敏感信息过滤
   function sanitizeUserData(userData) {
     const sanitized = { ...userData };
     
     // 移除敏感信息
     delete sanitized.password;
     delete sanitized.token;
     delete sanitized.creditCard;
     
     // 脱敏电话和邮箱
     if (sanitized.phone) {
       sanitized.phone = sanitized.phone.replace(/^(\d{3})\d{4}(\d{4})$/, '$1****$2');
     }
     
     if (sanitized.email) {
       const [name, domain] = sanitized.email.split('@');
       sanitized.email = `${name.charAt(0)}***@${domain}`;
     }
     
     return sanitized;
   }
   
   // 使用脱敏后的用户数据
   const user = getUserInfo();
   const sanitizedUser = sanitizeUserData(user);
   
   span.setAttribute('user.id', sanitizedUser.id);
   span.setAttribute('user.type', sanitizedUser.type);
   span.setAttribute('user.email', sanitizedUser.email);
   ```

4. **自定义业务指标**

   ```javascript
   // 创建业务指标记录器
   function createBusinessMetrics() {
     const meter = metrics.getMeter('business-metrics');
     
     // 转化率计数器
     const conversionCounter = meter.createCounter('business.conversion', {
       description: '转化次数',
     });
     
     // 订单金额直方图
     const orderValueHistogram = meter.createHistogram('business.order_value', {
       description: '订单金额分布',
       unit: 'CNY',
     });
     
     // 用户停留时间直方图
     const sessionDurationHistogram = meter.createHistogram('business.session_duration', {
       description: '用户会话时长',
       unit: 's',
     });
     
     return {
       recordConversion: (step, success = true) => {
         conversionCounter.add(1, {
           step,
           success: String(success),
         });
       },
       
       recordOrderValue: (value, category) => {
         orderValueHistogram.record(value, {
           category,
         });
       },
       
       recordSessionDuration: (duration, pageType) => {
         sessionDurationHistogram.record(duration, {
           page_type: pageType,
         });
       },
     };
   }
   
   // 使用业务指标
   const businessMetrics = createBusinessMetrics();
   
   // 记录转化
   document.querySelector('#signup-button').addEventListener('click', () => {
     businessMetrics.recordConversion('signup_click');
   });
   
   // 记录订单
   function handleOrderComplete(order) {
     businessMetrics.recordOrderValue(order.totalAmount, order.category);
   }
   
   // 记录会话时长
   window.addEventListener('beforeunload', () => {
     const duration = (Date.now() - window.performance.timing.navigationStart) / 1000;
     businessMetrics.recordSessionDuration(duration, getPageType());
   });
   ```

## 监控系统方案对比

### 功能对比

| 功能 | Sentry | WebTracing |
|------|--------|------------|
| 错误监控 | ✅ 完善 | ✅ 可定制 |
| 性能监控 | ✅ 内置 | ✅ 可扩展 |
| 用户行为追踪 | ⚠️ 有限 | ✅ 完全支持 |
| 分布式追踪 | ⚠️ 有限 | ✅ 原生支持 |
| SourceMap 支持 | ✅ 内置 | ⚠️ 需配置 |
| 告警系统 | ✅ 完善 | ⚠️ 需集成 |
| 多框架支持 | ✅ 内置 | ✅ 通过插件 |
| 自定义指标 | ⚠️ 有限 | ✅ 完全支持 |
| 数据导出 | ⚠️ 有限 | ✅ 多种选择 |
| 私有化部署 | ✅ 支持 | ✅ 支持 |

### 性能对比

| 性能指标 | Sentry | WebTracing |
|---------|--------|------------|
| SDK 体积 | 中等 (~20KB gzip) | 较大 (~30KB gzip) |
| 浏览器性能影响 | 低 | 中等 |
| 数据传输量 | 中等 | 可配置 |
| 后端资源消耗 | 高 | 中等 |
| 可扩展性 | 中等 | 高 |

### 成本对比

| 成本因素 | Sentry | WebTracing |
|---------|--------|------------|
| 初始搭建成本 | 低 | 高 |
| 维护成本 | 低 | 高 |
| 云服务成本 | 按事件计费 | 按资源使用计费 |
| 私有化部署成本 | 中等 | 高 |
| 定制开发成本 | 高 | 中等 |

### 适用场景

**Sentry 适用场景**：

1. 快速搭建监控系统，无需过多定制
2. 小型团队，人力资源有限
3. 主要关注错误监控和基本性能指标
4. 需要完善的告警和通知机制
5. 预算有限，希望使用成熟方案

**WebTracing 适用场景**：

1. 需要深度定制监控系统
2. 大型应用，需要全链路追踪能力
3. 已有 OpenTelemetry 生态系统
4. 对数据隐私和安全有严格要求
5. 需要与后端监控系统无缝集成

## 监控系统落地案例

### 大型电商平台监控实践

**背景**：某电商平台日活用户 100 万+，前端应用包含商城、后台管理、供应商平台等多个子系统。

**方案选择**：采用 WebTracing + Sentry 混合方案

**实施步骤**：

1. **基础设施搭建**
   - 部署 Sentry 私有化服务，用于错误监控
   - 部署 OpenTelemetry Collector 集群
   - 配置 Elasticsearch + Jaeger + Prometheus 存储
   - 搭建 Grafana 可视化平台

2. **监控接入**
   - 核心交易链路：使用 WebTracing 实现全链路追踪
   - 非核心页面：使用 Sentry 实现基础错误监控
   - 自定义业务指标：转化率、下单率、支付成功率等

3. **告警配置**
   - P0 级别：核心交易链路错误率 > 1%，立即告警
   - P1 级别：页面加载时间 P95 > 3s，或错误率 > 3%
   - P2 级别：非核心功能错误率 > 5%

4. **效果评估**
   - 问题发现时间：从平均 2 小时缩短至 5 分钟
   - 用户体验：页面加载时间平均减少 30%
   - 业务指标：转化率提升 15%，用户满意度提升 20%

### 中小型 SaaS 应用监控实践

**背景**：某 SaaS 企业协作平台，用户规模 5 万+，前端技术栈为 Vue + Element UI。

**方案选择**：采用 Sentry 云服务

**实施步骤**：

1. **初始配置**
   - 注册 Sentry 云服务账号
   - 集成 Sentry SDK 到 Vue 应用
   - 配置 SourceMap 上传

2. **监控范围**
   - 错误监控：JS 异常、API 请求异常
   - 性能监控：页面加载性能、API 请求性能
   - 用户信息关联：用户 ID、企业 ID、会员等级

3. **告警配置**
   - 工作时间：错误率 > 2%，Slack 通知
   - 非工作时间：错误率 > 5%，邮件通知
   - 核心功能：任何错误，立即通知

4. **效果评估**
   - 问题定位时间：从平均 1 天缩短至 1 小时
   - 开发效率：修复 bug 时间减少 40%
   - 用户反馈：负面反馈减少 30%

## 总结与展望

前端监控系统已经成为现代 Web 应用不可或缺的基础设施。通过本文介绍的 Sentry 和 WebTracing 两种方案，开发团队可以根据自身需求和资源情况选择合适的监控解决方案。

**关键收益**：

1. **提升用户体验**：通过实时监控和性能优化，提供更流畅的用户体验
2. **降低运维成本**：主动发现并解决问题，减少人工排查时间
3. **辅助业务决策**：基于用户行为数据，优化产品功能和流程
4. **提高开发效率**：快速定位问题，减少修复时间

**未来趋势**：

1. **AI 辅助分析**：利用机器学习自动分析异常模式和根因
2. **预测性监控**：基于历史数据预测可能出现的问题
3. **边缘计算**：在用户浏览器端进行初步数据处理和分析
4. **隐私保护增强**：更智能的数据脱敏和合规性保障
5. **跨平台监控**：Web、移动端、小程序等多平台统一监控